# -*- coding: utf-8 -*-
"""Projek Pertama-Time Series.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bXiSbnHCBqPW_5YLr25aVsSitblOHXlN

## Import Semua Packages/Library yang Digunakan
"""

!pip install colorama
!pip install yfinance statsmodels

import matplotlib.pyplot as plt
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from keras.callbacks import EarlyStopping, ReduceLROnPlateau
from sklearn.metrics import mean_absolute_error, mean_squared_error
from colorama import Fore, Style
from keras.optimizers import Adam
from sklearn.metrics import r2_score
import tensorflow as tf
from google.colab import drive
import pandas as pd
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.arima.model import ARIMA

"""## Data Understanding

Mengambil Data dari Google drive: Menggunakan library gdown untuk mendownload data harga saham BBCA selama 5 tahun terakhir.
"""

import gdown

# Download file dari Google Drive
file_id = "1reiW85TioMzROXzXqjyLcRTOzS43scI5"
url = f"https://drive.google.com/uc?id={file_id}"
output = "bbca_5y.csv"

gdown.download(url, output, quiet=False)

# Load CSV ke DataFrame
data = pd.read_csv(output, index_col="Date", parse_dates=True)

data.head()

"""Visualisasi Data: Memplot grafik harga penutupan saham BBCA untuk menggambarkan pergerakan harga selama periode yang ditentukan."""

# Plot harga penutupan (Close)
plt.figure(figsize=(12, 6))
plt.plot(data.index, data['Close'], label='Harga Penutupan', color='blue')

# Menambahkan judul dan label
plt.title('Harga Penutupan Saham BBCA (5 Tahun Terakhir)', fontsize=16)
plt.xlabel('Tanggal', fontsize=12)
plt.ylabel('Harga (IDR)', fontsize=12)

# Menampilkan grid dan legenda
plt.grid(True)
plt.legend()

# Tampilkan grafik
plt.show()

"""Mengecek missing value pada data"""

data.isnull().sum()

"""Mendeteksi outlier menggunakan metode IQR (interquartile Range)"""

Q1 = data[['Open', 'High', 'Low', 'Close', 'Adj Close', 'Volume']].quantile(0.25)
Q3 = data[['Open', 'High', 'Low', 'Close', 'Adj Close', 'Volume']].quantile(0.75)
IQR = Q3 - Q1

outliers = ((data < (Q1 - 1.5 * IQR)) | (data > (Q3 + 1.5 * IQR)))
outlier_count = outliers.sum()
outlier_count

"""Mengecek duplikat data"""

data.duplicated().sum()

"""Mengecek detail data dengan fungsi info()"""

data.info()

"""Selanjutnya kita melakukan decomposisi komponen waktu menggunakan metode seasonal decomposition. Dengan metode ini, data dapat dipecah menjadi tiga komponen utama: Trend, Seasonal, dan Residual, Untuk memahami lebih dalam struktur data harga saham BCA."""

result = seasonal_decompose(data['Close'], model='additive', period=30)

plt.figure(figsize=(12, 8))
plt.subplot(411)
plt.plot(result.observed, label='Observed')
plt.legend(loc='best')
plt.subplot(412)
plt.plot(result.trend, label='Trend')
plt.legend(loc='best')
plt.subplot(413)
plt.plot(result.seasonal, label='Seasonal')
plt.legend(loc='best')
plt.subplot(414)
plt.plot(result.resid, label='Residual')
plt.legend(loc='best')
plt.tight_layout()
plt.show()

"""## Data Preparation

Mengambil fitur Close atau harga penutupan sebagai fitur target yang akan digunakan untuk memprediksi harga saham BBCA
"""

data = data[['Close']]
data.head()

"""Menetapkan frekuensi harian dan menginterpolasi nilai NaN"""

data = data.asfreq(freq='D')
data.interpolate(inplace=True)

data.head()

# Membagi data menjadi train dan test
train_size = int(0.8 * len(data))
test_size = len(data) - train_size

print(f"Train Size: {train_size}")
print(f"Test Size: {test_size}")

"""Lengkah selanjutnya yaitu melakukan normalisasi data harga penutupan menggunakan MinMaxScaler ke rentang -1 hingga 0, mengatur time step menjadi 60 hari, membagi data menjadi set pelatihan dan pengujian, serta membentuk dataset dengan window 60 hari untuk digunakan dalam pelatihan model."""

# Normalisasi data
dataset = data.values

scaler = MinMaxScaler(feature_range=(-1, 0))
data_scaled = scaler.fit_transform(dataset)

# Membuat dataset dengan window 60 hari
time_step = 60

# Membagi data menjadi train dan test
train_data, test_data = data_scaled[:train_size-time_step,:], data_scaled[train_size-time_step:,:]

# Fungsi untuk membuat dataset dengan window (time_step)
def create_dataset(dataset, time_step=1):
    X, Y = [], []
    for i in range(len(dataset) - time_step - 1):
        a = dataset[i:(i + time_step), 0]  # Mengambil window data
        X.append(a)
        Y.append(dataset[i + time_step, 0])  # Nilai target
    return np.array(X), np.array(Y)

x_train, y_train = create_dataset(train_data, time_step)
x_test, y_test = create_dataset(test_data, time_step)

# Reshape input ke [samples, time steps, features]
x_train = np.reshape(x_train, (x_train.shape[0], x_train.shape[1], 1))
x_test = np.reshape(x_test, (x_test.shape[0], x_test.shape[1], 1))

print(len(x_train), len(x_test))

"""## Modeling

Selanjutnya adalah tahap modeling, disini kita akan menggunakan algoritma LSTM dan ARIMA. Kemudian kita akan membandingkan mana yang terbaik untuk memprediksi harga saham bbca

## 1. LSTM

Untuk model LSTM, disini saya menggunakan arsitektur 2 layer LSTM dengan masing-masing 50 unit, dan satu layer output. Konfigurasi ini diharapkan mampu menangkap pola yang ada dalam data time series.

Parameter yang digunakan adalah sebagai berikut:

- Loss Function: Mean Squared Error (MSE), yang umum digunakan dalam pemodelan regresi untuk menghitung selisih kuadrat antara nilai prediksi dan nilai aktual.
- Metrik Evaluasi: Mean Absolute Error (MAE), yang lebih mudah diinterpretasikan karena menampilkan kesalahan dalam satuan aslinya.
- Optimizer yang digunakan adalah Adam, yang cukup stabil dan efektif dalam mengidentifikasi pola dalam data.
- Epoch: 100, yang memberikan kesempatan cukup bagi model untuk belajar dari data.
- Batch Size: 32, ukuran batch ini sering digunakan karena memberikan keseimbangan antara kecepatan dan stabilitas pembelajaran.

Selain itu, kami juga menggunakan callback Early Stopping dengan parameter patience = 10, yang berarti model akan berhenti dilatih jika tidak ada penurunan pada validation loss selama 10 epoch berturut-turut. Teknik ini membantu menghemat waktu pelatihan dan memastikan penggunaan model terbaik, yaitu model dengan validation loss terendah selama pelatihan.
"""

# Membersihkan sesi sebelumnya
tf.keras.backend.clear_session()

# Membangun model LSTM
model = Sequential()
model.add(LSTM(50, return_sequences=True, input_shape=(x_train.shape[1], x_train.shape[2])))
model.add(LSTM(50))
model.add(Dense(1))

# Kompilasi Model
optimizer = Adam()

model.compile(optimizer=optimizer,
              loss='mean_squared_error',
              metrics=['mae'])

# Callback untuk early stopping jika validasi loss tidak meningkat dalam 10 epoch
early_stopping = EarlyStopping(
    monitor='val_loss',
    patience=10,
    restore_best_weights=True
)

# Pelatihan Model
history = model.fit(
    x_train,
    y_train,
    validation_data=(x_test, y_test),
    epochs=100,
    batch_size=32,
    callbacks=[early_stopping]
)

"""Memvisualisasikan loss dan val_loss bertujuan untuk melihat penurunan yang terjadi selama pelatihan model."""

plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Model Loss')
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.legend()
plt.show()

"""Langkah selanjunya yaitu melakukan prediksi dengan data test, kemudian membalik (reverse) hasilnya menjadi bentuk data asli. Selanjutnya, lakukan perhitungan metrik error, yaitu RMSE, R², dan MAPE"""

# Predict with the model
test_predicts = model.predict(x_test)

# Invert predictions
test_predict = scaler.inverse_transform(test_predicts)
y_test_inversed = scaler.inverse_transform(y_test.reshape(-1, 1))  # Ubah bentuk menjadi 2D

# Calculate Metric Error
score_rmse = np.sqrt(mean_squared_error(y_test_inversed, test_predict))
score_r2 = r2_score(y_test_inversed, test_predict)
score_mape = np.mean(np.abs((y_test_inversed - test_predict) / y_test_inversed)) * 100

print(Fore.GREEN + f'RMSE: {score_rmse:.4f}')
print(Fore.GREEN + f'MAPE: {score_mape:.2f}%')
print(Fore.GREEN + f'R2: {score_r2:.4f}')

"""Terakhir, buatlah plot dalam bentuk grafik agar kita dapat melihat hasilnya."""

# Plotting
plt.figure(figsize=(12, 6))

# Plot actual vs predicted
plt.plot(y_test_inversed, label='Actual Price', color='blue')
plt.plot(test_predict, label='Predicted Price', color='orange')

# Tambahkan judul dan label
plt.title('Actual vs Predicted Stock Prices')
plt.xlabel('Time Steps')
plt.ylabel('Stock Price')
plt.legend()
plt.grid()

# Tampilkan grafik
plt.show()

"""# 2. ARIMA

Untuk model kedua, kita akan menggunakan ARIMA, yang merupakan model yang sangat baik untuk memprediksi data time series. Pada model ini, kita mengatur parameter sebagai berikut:

- p=1: Ini artinya kita mempertimbangkan satu nilai sebelumnya untuk membantu memprediksi nilai saat ini.

- d=2: Parameter ini menunjukkan bahwa kita perlu melakukan differencing dua kali untuk membuat data kita stasioner. Pemilihan d=2 dikarenakan data saham ini memiliki tren yang kuat.

- q=1: Parameter ini menunjukkan bahwa kita memperhitungkan satu nilai residual (kesalahan) sebelumnya dalam model.

Dengan pengaturan parameter ini, diharapkan model ARIMA dapat memberikan hasil yang akurat dalam memprediksi data time series yang sedang dianalisis
"""

# Membersihkan sesi sebelumnya
tf.keras.backend.clear_session()

# Membagi data menjadi training dan test
train_size = int(len(data) * 0.8)
train, test = data[:train_size], data[train_size:]

# Train model arima
model = ARIMA(train, order=(1, 2, 1))
fitted_model = model.fit()

# Print model summary
print(fitted_model.summary())

# Buat predictions
predictions = fitted_model.forecast(steps=len(test))
test.index = predictions.index  # Align test index with predictions for accurate plotting

# Hitung metrik error
score_rmse = np.sqrt(mean_squared_error(test, predictions))
score_r2 = r2_score(test, predictions)
score_mape = np.mean(np.abs((test['Close'] - predictions) / test['Close'])) * 100

print(Fore.GREEN + f'RMSE: {score_rmse:.4f}')
print(Fore.GREEN + f'MAPE: {score_mape:.2f}%')
print(Fore.GREEN + f'R2: {score_r2:.4f}')

plt.figure(figsize=(10,6))
plt.plot(train, label='Training Data')
plt.plot(test, label='Actual Price')
plt.plot(predictions, color='red', label='ARIMA Predictions')
plt.title('BBCA Stock Price Prediction')
plt.xlabel('Date')
plt.ylabel('Price (IDR)')
plt.legend()
plt.show()

"""# Conclusion

Setelah membandingkan kedua model, dapat disimpulkan bahwa model LSTM menghasilkan performa yang superior dengan metrik evaluasi sebagai berikut:

- RMSE: 114.0646
- MAPE: 0.89%
- R²: 0.9569

Hal ini menunjukkan bahwa model LSTM lebih efektif dalam mengidentifikasi pola dalam data dibandingkan model ARIMA.
"""